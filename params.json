{"name":"Tumblelog","tagline":"Getting started with BDD and PhantomJs.","body":"# Getting started with BDD and PhantomJs in .Net.\r\n\r\n### How: Creating a simple asp.net mvc application by using SpecFlow + Phantom JS to drive the feature requirements.\r\n\r\nCreate a basic tumblelog application.\r\n\tA site for public to visit and view posts and comment on them.\r\n\tAn admin site that manages the posts.\r\n\r\nDev environment:\r\n\tWindows 7 or higher.\r\n\tVisual Studio 2013 (Professional or higher to enable Specflow addon support like syntax highlighting, templates, etc by default).\r\n\t\tIf you cannot go beyond the Express version, you can use Alister Scott's guide to enable Specflow integration:\r\n\t\t\thttp://watirmelon.com/2011/02/18/c-sharp-atdd-on-a-shoestring/\r\n\t\t\tAlthough Alister's guide is for Visual Studio 2012, a little bit of work can get the Visual Studio 2013 version working as well.\r\n\t\t\t\r\n\tSpecFlow (What is it?).\r\n\tPhantom JS ( What is it?).\r\n\tSql CE for persistence of data (not the ideal database, but for this instance let's stick with it).\r\n\t\r\nThe goal of this experiment is to learn SpecFlow, PhantomJS and using  BDD / ATDD to drive the creation of an application.\r\n\r\nWhat is BDD / ATDD?\r\n\tBehavior-driven development or BDD is a development process based on TDD (Test driven development).\r\n\tThis process is also sometimes called ATDD or Acceptance Tests Driven Development.\r\n\tYou can find an introduction to BDD via the now famous blog post by Dan North introducing BDD to the world http://dannorth.net/introducing-bdd/.\r\n\tThe Wikipedia entry for BDD also has a decent introduction:\r\n\thttp://en.wikipedia.org/wiki/Behavior_Driven_Development\r\n        As I use it more and more, the term Executable Specifications makes more sense to me than BDD / ATDD.\r\n        The feature files containing the tests become more like a living documentation of the system.\r\n\r\nWhat is SpecFlow, how does it fit in?\r\n\tSpecFlow brings BDD to .Net projects, it's one of the most mature of all the tools / frameworks in the .net space. \r\n\tSpecFlow supports the Gherkin syntax / language used by BDD to define the behavior for your application.\r\n\tSpecFlow has IDE integration for Visual Studio to bring in templates, syntax highlighting etc.\r\n\t\thttp://www.specflow.org/documentation/Install-IDE-Integration/\r\n\tSpecFlow is available on NuGet and can be installed as a reference for your project by using the command\r\n\t\tinstall-package SpecFlow\r\n\tThe approach to using SpecFlow in your SDLC will be something like this:\r\n\t\r\n\tBegin by writing Gherkin based behaviors for your application.\r\n\tGenerate tests from those behaviors (Specflow supports the following testing frameworks http://www.specflow.org/documentation/Unit-Test-Providers/), these tests would fail as they would have no implementation.\r\n\tWrite code to make those tests pass.\r\n\tRinse and repeat.\r\n\tNote: As these are acceptance tests, they are at a higher level than unit and integration tests.\r\n\t\r\nWhat is PhantomJS?\r\n\tIf your web application needs to be tested via the browser in an automated fashion, the selenium framework would be the ideal candidate for handling that task. \r\n\tThe traditional way to test using selenium is to either use the selenium batch processing language (selenese) or to use the selenium library in your test project and drive the automated tests through it.\r\n\tThe selenium framework talks to the respective browser instance and carries out actions. This approach, while it gets the application tested, is very slow for scenarios like regression tests, smoke tests where you have to verify if your functional tests are not breaking and it does not matter if all the browsers are displaying the elements correctly.\r\n\tEnter headless browser testing. \r\n\tA headless browser is an instance of a browser engine with no UI overhead. Shedding the UI weight gives the instance a big advantage in performance. \r\n\tOne of the most popular frameworks for handling the headless browser testing tasks is PhantomJS. (http://phantomjs.org).\r\n\tSelenium supports PhantomJS as a browser and can easily be plugged into your testing life-cycle.\r\n\tUsing a headless framework like PhantomJS also benefits a CI environment where you don't have to worry about setting up browser(s).\r\n\t\r\nPrequel:\r\n\r\nBrowse to http://www.specflow.org/documentation/Install-IDE-Integration/\r\n\r\nFollow the instructions to get SpecFlow installed.\r\n\r\n\r\nFile->New Project\r\n\r\n\tStart Visual Studio and click File->New Project, select Web from the templates list on the left and select 'ASP.Net Web Application':\r\n\t\r\n\r\n\r\nI am using Visual Studio 2013 with Update 2 (RC as of this time), if you are using a different version of Visual Studio or a version of .Net framework < 4.5, your selection dialog will be different.\r\n\r\nIf using an older version of Visual Studio or using a different version of .Net Framework, select an ASP.Net MVC project.\r\n\r\nEnter Tumblelog as the application name, Click Ok.\r\n\r\nOn the next dialog, select MVC and check the Add unit tests option, click Ok.\r\n\r\n\r\n\r\nOn an older version of Visual Studio or a different version of .Net Framework:\r\n\r\n\r\n\r\nSelect Internet Application, check the 'Create a unit test project' option, click Ok.\r\n\r\nFrom the Solution Explorer, delete all the default / auto-generated files from the test project.\r\n\r\nClick Tools-> NuGet Package Manager ->  Package Manager Console.\r\n\r\nIn the Package Manager Console Window, type these commands:\r\n\r\n\tinstall-package SpecFlow\r\n\tinstall-package Selenium.WebDriver\r\n\tinstall-package PhantomJS\r\n\r\n\r\n\r\nRemember to set the Default project to your tests project.\r\n\r\nOr you can specify the project name in the command by using the -ProjectName option.\r\n\tinstall-package -ProjectName <YourTestProjectNameGoesHere> SpecFlow\r\n\tinstall-package -ProjectName <YourTestProjectNameGoesHere> Selenium.WebDriver\r\n\tinstall-package -ProjectName <YourTestProjectNameGoesHere> PhantomJS\r\n\t\r\n\r\nOpen the app.config file from the test project.\r\nAdd the respective line for your choice of testing framework in the <specFlow> section:\r\n\r\n\t<unitTestProvider name=\"MSTest\" /> \r\n\r\nRefer to this url for supported unit test frameworks in SpecFlow:\r\n\r\nhttp://www.specflow.org/documentation/Unit-Test-Providers/\r\n\r\nClick Project->Add New Item.\r\n\r\n\r\n\r\nSelect SpecFlow Feature File, name it TumblelogView.feature, click Add.\u000B\r\nOpen the newly created file, you should see a dummy Feature and a scenario definition associated with it.\r\n\r\nDelete the content of the file and enter:\r\n\r\n\tFeature: TumblelogView\r\n\t\tIn order to launch my blog\r\n\t\tI have to make my tumblelog site viewable\r\n\t\r\n\t@homepage\r\n\tScenario: Browse to home page\r\n\t\tGiven I have to view the home page\r\n\t\tWhen I browse to the home page\r\n\t\tThen the page should have the title of 'My Tumblelog'\r\n                     And the heading on the page should be 'My Tumblelog'\r\n\t\r\n\r\nRight-click anywhere in the feature file view and click Generate Step Definitions.\r\n\r\n\r\n\r\nClick Generate.\r\n\r\nSave the file in the next dialog window.\r\n\r\nA new class file named <Feature-name>View.cs will be created, when you open this file you may be seeing a warning:\r\n\r\n\r\n\r\n\r\nClick Yes to normalize the line endings to Windows (CR LF).\r\n\r\n\r\nThe class should have the following code generated for the scenario steps:\r\n   \r\n\t    [Binding]\r\n\t    public class TumblelogViewSteps {\r\n\t        [Given(@\"I have to view the home page\")]\r\n\t        public void GivenIHaveToViewTheHomePage() {\r\n\t            ScenarioContext.Current.Pending();\r\n\t        }\r\n\t\r\n\t        [When(@\"I browse to the home page\")]\r\n\t        public void WhenIBrowseToTheHomePage() {\r\n\t            ScenarioContext.Current.Pending();\r\n\t        }\r\n\t\r\n\t        [Then(@\"the page should have the title of '(.*)'\")]\r\n\t        public void ThenThePageShouldHaveTheTitleOf(string p0) {\r\n\t            ScenarioContext.Current.Pending();\r\n\t        }\r\n\t\r\n\t        [Then(@\"the heading on the page should be '(.*)'\")]\r\n\t        public void ThenTheHeadingOnThePageShouldBe(string p0) {\r\n\t            ScenarioContext.Current.Pending();\r\n\t        }\r\n\t\r\n\t\r\nYou would see that each of the steps defined in the feature file has a corresponding method generated.\r\n\r\nThe Given, When, Then scenarios are your Arrange, Act & Assert of TDD.\r\n\r\nClick Test->Windows->Test Explorer or if using vs 2013 press Ctrl+Q and type test explorer and press enter.\r\n\r\nClick Run All.\r\n\r\nYou should see the results of the test run with the message:\r\n\r\n\tAssert.Inconclusive failed. One or more step definitions are not implemented yet.\r\n\t  TumblelogViewSteps.GivenIHaveToViewTheHomePage()\r\n\t\r\nNow we start plugging in code to make our tests pass.\r\n\r\nIn the TumblelogView feature file:\r\n\r\nRight-click on the first Step, i.e. Given I have to view the home page and click on Go to Step Definition.\r\n\r\n\r\nFor the Given / Arrange part, we have to setup the webdriver to use PhantomJS as a browser.\r\n\r\nDefine a private class-wide instance of the webdriver by declaring:\r\n\tprivate IWebDriver driver;\r\n\r\nIn the GivenIHaveToViewTheHomePage method, add the following code:\r\n\tdriver = new PhantomJSDriver();\r\n           driver.Manage().Timeouts().ImplicitlyWait(new TimeSpan(0, 0, 10));\r\n\t\r\nThis sets up the PhantomJS driver to wait to find an element for a maximum of 10 seconds. You can set it lower if you want, and start increasing little by little if you start seeing timeouts. The 10 second value is a conservative one.\r\n\r\nIf you do a run all again, you would see that the next step (Act) , i.e. WhenIBrowseToTheHomePage now fails.\r\n\r\nLet's work on this step now, this method requires the webdriver to browse to the home page of the site, as the site's project is part of the same solution, we need to get the IIS express url of the website.\r\n\r\nTo do that, go to solution explorer, select Tumblelog project and press F4.\r\n\r\n\r\n\r\nIn the properties dialog that comes up, copy the value of the URL property.\r\n\r\n\r\n\r\n\r\nOpen app.config for the test project and add the following entry in the appSettings section (add the appSettings section if it does not already exist):\r\n\r\n\t  <appSettings>\r\n\t    <add key=\"home\" value=\"<value of the URL property goes here>\"/>\r\n\t  </appSettings>\r\n\t\r\n\r\nThis will give our tests a starting point for our site. As this web application is not deployed yet, we would have to start an instance of it and then run the tests to browse to it.\r\n\r\nI am not sure if this is an ideal way to do it or not, if I do find one, I will update the post.\r\n\r\nIn the TumblogViewSteps.cs class's WhenIBrowseToTheHomePage method, add the following code:\r\n\r\n\tdriver.Navigate().GoToUrl(ConfigurationManager.AppSettings[\"home\"]);\r\n\r\nThe Act step is now complete, this means we are ready to test it.\r\n\r\nTo do this, make the Tumblelog web application project the Startup project and press Ctrl + F5 to start the app without debugging.\r\n\r\nOnce the application has started (browser comes up with website), go to the Test project, then in Test Explorer, click Run All.\r\n\r\nThe test results should now reflect that the failing step should be ThenThePageShouldHaveTheTitleOfMyTumblelog.\r\n\r\nThis is the assert portion of the test. Let's go make that step pass.\r\n\r\nAdd the following code to the ThenThePageShouldHaveTheTitleOfMyTumblelog method:\r\n\t\r\n\tAssert.AreEqual(p0,driver.Title);\r\n\r\nRunning this test will show that the test still fails as the home page title hasn't been changed, let's get this corrected.\r\n\r\nIn the Tumblelog web application project, open Views\\Home\\Index.cshtml\r\n\r\nChange the value of ViewBag.Title to \"My Tumblelog\".\r\n\r\nOpen Views\\Shared\\_layout.cshtml.\r\n\r\nChange the value of the title tag to @ViewBag.Title.\r\n\t\r\n\t<title>@ViewBag.Title</title>\r\n\t\r\nRun the test, the test should now pass.\r\n\r\nThe final step in this scenario is to verify if the heading on the page is 'My Tumblelog', for this we have to change the <h1> tag in the \r\n\r\nfile Views\\Home\\Index.cshtml in the Tumblelog web application project.\r\n\r\nOpen Views\\Home\\Index.cshtml and change the value in the <h1> tag to 'My Tumblelog'.\r\n\r\nNow how do we verify this in our test?\r\n\r\nWe can look for a <h1> tag in the document and compare the values, this approach is unstable as the document can introduce more <h1> tags during the design phase.\r\n\r\nWe need to identify the tag which is meant to signify the main heading for the page and give it an uniquely identifiable name.\r\n\r\nChange the line <h1>ASP.NET</h1> to <h1 id=\"PageHeading\">My Tumblelog</h1>.\r\n\r\nNote: Do not use the attribute name as it is not considered unique in an html document, id however is.\r\n\r\nAdd the following line to the method ThenTheHeadingOnThePageShouldBe in the TumblelogViewSteps.cs file:\r\n\r\n\tAssert.AreEqual(p0, driver.FindElement(By.Id(\"PageHeading\")).Text);\r\n\t\r\n\r\nNow all your steps and your test should pass.\r\n\r\n\r\nRecap:\r\n\r\nWhat have we done so far?\r\n\tWe established a scenario for our application that the home page for our application is defined by 2 elements once browsed to the home page url:\r\n\t\r\n\t\t1) The title of the page having the value of 'My Tumblelog'.\r\n\t\t2) A heading / element on the page identified by the id 'PageHeading' having a value of 'My Tumblelog'.\r\n\r\n\tWe created tests to ensure that this scenario is true when the application is navigated to its home page.\r\n\t\r\n\tWe made changes in the application to ensure that the tests pass.\r\n\t\r\nWhat does this get us?\r\n\tDuring the development of the project, the html content is definitely going to change, the test above will ensure that the scenario which is considered a home page stays true.\r\n\t\r\nWhat happens if the scenario for considering a page a home page changes?\r\n\tIf it does, then make changes to the feature file and define the criteria and then move forward with making the actual changes.\r\n\t\r\n\tThat way you get a chance to clearly define the requirement and carry forward with the TDD mantra of test first.\r\n\r\n\r\n\r\nPersistence\r\n\r\nTime to add some persistence to the blog.\r\n\r\nFor this experiment I am using SQL Server Compact Edition.\r\n\r\nWe need to create our database and setup the tables.\r\n\r\nThe script I have come up for this looks like this:\r\n\r\nCREATE DATABASE 'd:\\data\\tumblelog.sdf' DATABASEPASSWORD 'tumble1234';\r\nCREATE TABLE posts (postid INT IDENTITY PRIMARY KEY, title NVARCHAR(250) NOT NULL, body NVARCHAR(4000) NOT NULL, slug VARCHAR(100), created_on DATETIME NOT NULL);\r\nCREATE TABLE comments (postid INT, body NVARCHAR(200) NOT NULL, author NVARCHAR(150) NOT NULL, created_on DATETIME NOT NULL);\r\n\r\nSo now, how do we create it? We can either use the designer in Visual Studio to manually create it, use a migrations tool or we can do it in C#.\r\n\r\nThere are a bunch of good migration tools out there like RoundHouse, Manatee, migrator.net, etc. The database support for them varies, and in my work environment I am faced with interacting with databases like Informix which is uncommon in the development world.\r\n\r\nIn C# the code would look something like this:\r\n\r\n\tusing System.Data.SqlServerCe;\r\n\tusing System.IO;\r\n\tpublic string void Main(string[] args) {\r\n\t           var fileName = “d:\\data\\tumblelog.sdf”;\r\n\t           var password = “tumble1234”;\r\n\t\tvar sqlLine1 = \"CREATE TABLE posts (postid INT IDENTITY PRIMARY KEY, title NVARCHAR(250) NOT NULL, body NVARCHAR(4000) NOT NULL, slug NVARCHAR(100), created_on DATETIME NOT NULL);\"\r\n\t\tvar sqlLine2 = \"CREATE TABLE comments (postid INT, body NVARCHAR(200) NOT NULL, author NVARCHAR(150) NOT NULL, created_on DATETIME NOT NULL);\"\r\n\t           if (File.Exists(fileName)){\r\n\t              File.Delete(fileName);\r\n\t           }\r\n\t           var connectionString = string.Format(“DataSource=\\”{0}\\”; Password=’{1}’”, fileName, password);\r\n\t           var en = new SqlCeEngine(connectionString);\r\n\t           en.CreateDatabase();\r\n\t\tusing (var sqlServerConnection = new SqlCeConnection(connectionString)) {\r\n\t\t                        sqlServerConnection.Open();\r\n\t\t                        using (var sqlServerCommand = new SqlCeCommand(sqlLine1, sqlServerConnection)) {\r\n\t\t                            sqlServerCommand.ExecuteNonQuery();\r\n\t\t\t\t      sqlServerCommand.CommandText = sqlLine2;\r\n\t\t\t\t      sqlServerCommand.ExecuteNonQuery();\r\n\t\t                        }\r\n\t\t }\r\n\t}\r\n\r\nGranted the above code could be refactored to make it cleaner,  the action of creating a database at will, might never be clean at least for Sql Server CE, what if you do want to go to a different database altogether like say PostgreSQL?  You cannot keep creating code for different databases to run your script.\r\n\r\nFurthermore, your database is bound to change from the above baseline to accommodate new features / enhancements, which would mean you would have to revisit the code every time you had a change in the schema.\r\n\r\nWhen integrating with a continuous integration system, your build system should be able to automate the task of creating / migrating the database.\r\n\r\nFor suiting my needs, I have written a sql runner having a plug-in system of vendor based \"runners\" called RunSqlRun (rsr for short):\r\n\r\nhttps://github.com/fallenprogrammr/RunSqlRun\r\n\r\nThe goal of the project is to have xcopy deployable system runners to the maximum extent as possible\r\n\r\nThis gives me the flexibility I need to target any database system I want by adding a vendor specific runner to the mix.\r\n\r\nFor this project I will be dogfooding rsr to see how well it holds up to the task.\r\n\r\nI have not yet finalized the deployment mechanism for NuGet, but when I do this should be simple as Install-Package rsr.Postgres and you can now run scripts for targeting postgresql databases from your code.\r\n\r\n\r\nLet's start this from a sql runner's perspective, \r\n\r\nFirst, let's create a .sql file that will create our database and tables having the following sql statements:\r\n\r\n\tCREATE DATABASE 'd:\\data\\tumblelog.sdf' DATABASEPASSWORD 'tumble1234';\r\n\tCREATE TABLE posts (postid INT IDENTITY PRIMARY KEY, title NVARCHAR(250) NOT NULL, body NVARCHAR(4000) NOT NULL, slug NVARCHAR(100), created_on DATETIME NOT NULL);\r\n\tCREATE TABLE comments (postid INT, body NVARCHAR(200) NOT NULL, author NVARCHAR(150) NOT NULL, created_on DATETIME NOT NULL);\r\n\t\r\nAdd it to your solution.\r\n\r\nCopy the current rsr binaries from <todo: location of binaries like dropbox / onedrive> to your machine and create the database using the command:\r\n\r\n\trsr v:SqlServerCe s:CreateDatabaseAndTables.sql\r\n\r\n\r\n\r\nThis should create the required database for our tumblelog.\r\n\r\nWe now need to move back to visual studio to define our next test steps.\r\n\r\nIn our scenario \"Browse to home page\", we would be adding a couple of steps.\r\n\r\nThese will require our setup stage to take more steps to create our database from scratch and then populate the tables with data that we can use for testing our page behaviors with.\r\n\r\nAdd these 2 lines to the \"Browse to home page\" scenario:\r\n\r\n\t And the page should display the summaries of the latest 5 blog entries\r\n\t And the total count of entries in the database should match the total count shown on the home page\r\n\t\r\nThese 2 new lines should now show up in a different color than the rest of scenario, what this means is SpecFlow could not find any related code matching that test step.\r\n\r\nLet's add the code, right click the file and click 'Generate step definitions'.\r\n\r\nIn the dialog that comes up, select the 2 steps and click 'Copy methods to clipboard' button and not the Generate button.\r\n\r\n\r\n\r\n\r\n\r\nThis is because the generate button overwrites the contents of the generated code if it exists, which we don't want.\r\n\r\nOpen TumbleLogViewSteps.cs.\r\n\r\nPaste the copied code, the copied code should look like this:\r\n\r\n\t[Then(@\"the page should display the summaries of the latest (.*) blog entries\")]\r\n\tpublic void ThenThePageShouldDisplayTheSummariesOfTheLatestBlogEntries(int p0)\r\n\t{\r\n\t    ScenarioContext.Current.Pending();\r\n\t}\r\n\t\r\n\t[Then(@\"the total count of entries in the database should match the total count shown on the home page\")]\r\n\tpublic void ThenTheTotalCountOfEntriesInTheDatabaseShouldMatchTheTotalCountShownOnTheHomePage()\r\n\t{\r\n\t    ScenarioContext.Current.Pending();\r\n\t}\r\n\t\r\nLet's begin our arrange, act, assert for these steps.\r\n\r\nArrange:\r\n\tIn the GivenIHaveToViewTheHomePage method we would have to \r\n\t\t1) Create the database file.\r\n\t\t2) Setup the tables.\r\n\t\t3) Add data in the tables for evaluating the test cases.\r\n\r\nAct:\r\n\tThis is already complete in the WhenIBrowseToTheHomePage method.\r\n\r\nAssert:\r\n\tIn ThenThePageShouldDisplayTheSummariesOfTheLatestBlogEntries method we would have to make sure that the summaries of the last 5 blog entries are displayed on the page.\r\n\t\r\nThe arrange part starts to become tricky as the application and the test suite have to use the same database.\r\n\r\nFirst we would need to define the database connection string which will be shared between the two projects.\r\n\r\nFor this demo, we will be using d:\\data\\tumblelog.sdf as our path to the database file.\r\n\r\nIn the web.config (tumblelog asp.net mvc project) and app.config (tumblelog acceptance tests project) add a new entry in the connectionStrings section:\r\n\r\n\t<add name=\"tumblelogDb\" connectionString=\"Data Source=d:\\data\\tumblelog.sdf; Password=tumble1234\"/>\r\n\r\nCreating the database file and setting up the tables and adding data can be done by using sql script files.\r\n\r\nWe can create 1 for setup, and 1 for adding the data, this way we can reuse the setup script later in other scenarios.\r\n\r\nCreate a new .sql file by using the 'Text File' template named CleanupTables.sql and add the following code:\r\n\r\n\tDELETE FROM comments;\r\n\tDELETE FROM posts;\r\n\r\nIn the properties dialog for the above file, set the Build Action to Content and Copy to Output Directory to Copy if newer.\r\n\r\nRight above the GivenIHaveToViewTheHomePage method add the following attribute to let the testing framework (MS / VS Test in this case) know that there is a file that should be deployed along with the assemblies before running the test:\r\n\r\n\t[DeploymentItem(\"DatabaseAndTablesSetup.sql\")]\r\n\r\nAdd a reference to the SqlServerCeRunner, (NuGet, Dropbox, OneDrive implementation for copying / sharing).\r\n\t\r\nInsert the following code to the GivenIHaveToViewTheHomePage method:\r\n\r\n\t            var scriptRunner = new SqlServerCeRunner.Runner(ConfigurationManager.ConnectionStrings[\"tumblelogDb\"].ConnectionString);\r\n\t            scriptRunner.RunFile(\"CleanupTables.sql\");\r\n\t\r\nNow that our tables are setup, we need to add data to them to make sure when the home page is rendered it displays the required elements.\r\n\r\nCreate a new .sql file in the acceptance test project named 'HomePageTestData.sql' and add the following lines of sql statements:\r\n\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post1','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post1', DATEADD(day,-14,GETDATE()));\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post2','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post2', DATEADD(day,-12,GETDATE()));\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post3','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post3', DATEADD(day,-10,GETDATE()));\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post4','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post4', DATEADD(day,-7,GETDATE()));\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post5','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post5', DATEADD(day,-5,GETDATE()));\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post6','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post6', DATEADD(day,-4,GETDATE()));\r\n\tINSERT INTO post(title, body, slug, created_on) VALUES ('acceptance-test-post7','This is an acceptance test post, used for testing purposes only.', 'acceptance-test-post7', DATEADD(day,-1,GETDATE()));\r\n\t\r\nIn the script we insert 7 rows in the post table with different dates, this will set our data up for our home page tests.\r\n\r\nThe total count on the page should now show 7 and the recent posts should show the posts titled post7 - post3.\r\n\r\nLet's make it happen.\r\n\r\nRight above the GivenIHaveToViewTheHomePage method add the following attribute to let the testing framework (MS / VS Test in this case) know that there is a file that should be deployed along with the assemblies before running the test:\r\n\r\n[DeploymentItem(\"HomePageTestData.sql\")]\r\n\r\nAdd the following line of code at the end of the GivenIHaveToViewTheHomePage method:\r\n\r\n\tscriptRunner.RunFile(\"HomePageTestData.sql\");   \r\n\r\n\r\nRun the web application and run the tests to see if the setup steps are working fine.\r\n\r\nThe result of the test run should be:\r\n\r\n\tAssert.Inconclusive failed. One or more step definitions are not implemented yet.\r\n\t  TumblelogViewSteps.ThenThePageShouldDisplayTheSummariesOfTheLatestBlogEntries(5)\r\n\t\r\nLet's get this fixed:\r\n\r\nCreate a Model (loose definition: A representation of a data structure, used in the database) for a post.\r\n\r\nAdd a new class, PostModels in the \\Models directory, add the following code.\r\n\r\n\tusing System;\r\n\tusing System.Collections.Generic;\r\n\tusing System.ComponentModel.DataAnnotations;\r\n\t\r\n\tnamespace Tumblelog.Models {\r\n\t        public class Post {\r\n\t            [Key]\r\n\t            public int PostId { get; set; }\r\n\t            [DataType(DataType.Text)]\r\n\t            public string Slug { get; set; }\r\n\t            [DataType(DataType.Text)]\r\n\t            public string Title { get; set; }\r\n\t            [DataType(DataType.Text)]\r\n\t            public string Body { get; set; }\r\n\t            [DataType(DataType.DateTime)]\r\n\t            public DateTime CreatedOn { get; set; }\r\n\t        }\r\n\t\r\n\t    public class HomePageModel {\r\n\t        public List<Post> LatestPosts {get;set;}\r\n\t        public int TotalPosts { get; set; }\r\n\t\r\n\t        public HomePageModel() {\r\n\t            LatestPosts = new List<Post>();\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\nThe data annotations added on top of each property is used by the asp.net mvc runtime to handle the rendering of controls smartly.\r\n\r\nCreate a new interface named IPostRepository.cs in the Models directory(yes, this is 2014 and I am using a repository, get over it).\r\n\r\nIn this demo, I am not using any orm / orm-lite and am sticking to pure sql queries to drive the requirements to keep it simple, you can model your data layer however you want.\r\n\r\nAdd the following code:\r\n\r\n\tnamespace Tumblelog.Models {\r\n\t    public interface IPostRepository {\r\n\t        HomePageModel GetHomePageModel();\r\n\t    }\r\n\t}\r\n\r\nAdd a new class SqlCePostRepository.cs in the \\Models directory (this class inherits the IPostRepository interface defined above) and add the following code:\r\n\r\n\tusing System.Configuration;\r\n\tusing System.Data.SqlServerCe;\r\n\tnamespace Tumblelog.Models {\r\n\t    public class SqlCePostRepository : IPostRepository{\r\n\t\r\n\t        public HomePageModel GetHomePageModel() {\r\n\t            //SqlServerCe does not support multiple resultsets or subqueries, hence the running of 2 seperate queries in this example (my sql-fu is rusty maybe?).\r\n\t            var homePageModel = new HomePageModel();\r\n\t            using (var sqlCeConnection = new SqlCeConnection(ConfigurationManager.ConnectionStrings[\"tumblelogDb\"].ConnectionString)) {\r\n\t                sqlCeConnection.Open();\r\n\t                const string getAllPostsQuery = \"SELECT TOP 5 postid, title, body, slug, created_on FROM posts ORDER BY created_on DESC;\";\r\n\t                const string getTotalPostsCountQuery = \"SELECT COUNT(*) as total_posts FROM posts;\";\r\n\t                using (var getAllPostsCommand = new SqlCeCommand(getAllPostsQuery, sqlCeConnection)) {\r\n\t                    using (var allPostsReader = getAllPostsCommand.ExecuteReader()) {\r\n\t                        while (allPostsReader.Read()) {\r\n\t                            homePageModel.LatestPosts.Add(new Post() {\r\n\t                                PostId = allPostsReader.GetInt32(allPostsReader.GetOrdinal(\"postid\")),\r\n\t                                Slug = allPostsReader.GetString(allPostsReader.GetOrdinal(\"slug\")),\r\n\t                                Title = allPostsReader.GetString(allPostsReader.GetOrdinal(\"title\")),\r\n\t                                Body = allPostsReader.GetString(allPostsReader.GetOrdinal(\"body\")),\r\n\t                                CreatedOn = allPostsReader.GetDateTime(allPostsReader.GetOrdinal(\"created_on\"))\r\n\t                            });\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t                using (var getTotalPostsCommand = new SqlCeCommand(getTotalPostsCountQuery,sqlCeConnection)) {\r\n\t                    using (var totalPostsReader = getTotalPostsCommand.ExecuteReader()) {\r\n\t                        if (totalPostsReader.Read()) {\r\n\t                            homePageModel.TotalPosts =\r\n\t                                totalPostsReader.GetInt32(totalPostsReader.GetOrdinal(\"total_posts\"));\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return homePageModel;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\r\nIn the HomeController.cs class's Index method, remove the default return View(); statement and add the following code:\r\n\r\n\t            var postsRepo = new SqlCePostRepository();\r\n\t            return View(postsRepo.GetHomePageModel());\r\n\r\n\r\nOpen \\Views\\Home\\index.cshtml in the tumblelog asp.net mvc application and replace the existing content by:\r\n\r\n\t@{\r\n\t    ViewBag.Title = \"My Tumblelog\";\r\n\t}\r\n\t@using Tumblelog.Models\r\n\t@model HomePageModel\r\n\t<div class=\"jumbotron\">\r\n\t    <h1 id=\"PageHeading\">My Tumblelog</h1>\r\n\t    <p class=\"lead\">Welcome to my tumblelog.</p>\r\n\t</div>\r\n\t\r\n\t<div class=\"row\">\r\n\t    \r\n\t    @foreach (var post in Model.LatestPosts) {\r\n\t        <div id=\"recentBlogPosts\" class=\"col-md-4\">\r\n\t            <h4 id=\"postHeading\">@post.Title</h4>\r\n\t            <p>@post.Body.Substring(0, 20)...</p>\r\n\t            <p>Created on: @post.CreatedOn</p>\r\n\t        </div>\r\n\t    }\r\n\t</div>\r\n\r\nLet's add some assertions to our test to validate the content.\r\n\r\nIn the ThenThePageShouldDisplayTheSummariesOfTheLatestBlogEntries method, add the following code:\r\n\r\n\t            Assert.AreEqual(p0, driver.FindElements(By.Id(\"recentBlogPosts\")).Count);\r\n\t            var headings = driver.FindElements(By.Id(\"postHeading\"));\r\n\t            foreach (var heading in headings) {\r\n\t                Assert.IsTrue(heading.Text == \"acceptance-test-post7\" || heading.Text == \"acceptance-test-post6\" || heading.Text == \"acceptance-test-post5\" || heading.Text == \"acceptance-test-post4\" || heading.Text == \"acceptance-test-post3\");\r\n\t            }\r\n\r\nHaving 2 asserts in a test is a test smell (test is asserting too much), it would be better if the conditions were broken down into 2 and then the tests would look more cleaner (for the purposes of this tutorial, I will keep them in this single method).\r\n\r\nRunning the tests now should show all but the last test remaining:\r\n\r\n\tGiven I have to view the home page\r\n\t-> done: TumblelogViewSteps.GivenIHaveToViewTheHomePage() (1.7s)\r\n\tWhen I browse to the home page\r\n\t-> done: TumblelogViewSteps.WhenIBrowseToTheHomePage() (0.3s)\r\n\tThen the page should have the title of 'My Tumblelog'\r\n\t-> done: TumblelogViewSteps.ThenThePageShouldHaveTheTitleOf(\"My Tumblelog\") (0.0s)\r\n\tAnd the heading on the page should be 'My Tumblelog'\r\n\t-> done: TumblelogViewSteps.ThenTheHeadingOnThePageShouldBe(\"My Tumblelog\") (0.1s)\r\n\tAnd the page should display the summaries of the latest 5 blog entries\r\n\t-> done: TumblelogViewSteps.ThenThePageShouldDisplayTheSummariesOfTheLatestBlogEntries(5) (0.2s)\r\n\tAnd the total count of entries in the database should match the total count shown on the home page\r\n\t-> pending: TumblelogViewSteps.ThenTheTotalCountOfEntriesInTheDatabaseShouldMatchTheTotalCountShownOnTheHomePage()\r\n\t\r\n\tAssert.Inconclusive failed. One or more step definitions are not implemented yet.\r\n\t  TumblelogViewSteps.ThenTheTotalCountOfEntriesInTheDatabaseShouldMatchTheTotalCountShownOnTheHomePage()\r\n\r\nGoing back to our view i.e. Views\\index.cshtml, add the following code:\r\n\r\n\t<div class=\"row\">\r\n\t    <p id=\"totalBlogPosts\">@Model.TotalPosts total blog posts so far.</p>    \r\n\t</div>\r\n\r\nIn the method ThenTheTotalCountOfEntriesInTheDatabaseShouldMatchTheTotalCountShownOnTheHomePage add the following code to assert that the count is correct:\r\n\r\n            const int expectedTotalPosts = 7;\r\n            Assert.IsTrue(driver.FindElement(By.Id(\"totalBlogPosts\")).Text.Equals(expectedTotalPosts + \" total blog posts so far.\"));\r\n\r\nRunning the tests should now show that all the tests are passing, sweet.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}